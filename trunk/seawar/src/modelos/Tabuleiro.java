package modelos;


import java.io.Serializable;
import java.util.Random;
//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : @Seawar
//  @ File Name : Tabuleiro.java
//  @ Date : @06/05/2011
//  @ Author : @Fernando
//
//



//Classe relacionada ao Tabuleiro do Jogo.
public class Tabuleiro implements Serializable{
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	public Celula[][] mMatrizCelula;
	public Celula[][] mCelulasAtacadas;
	public boolean bTravaTabuleiro;
	public boolean bTurno;
	public Jogador oJogador;
	public Embarcacao[] arrEmbarcacoes;
	
	private final int QUANTIDADE_EMBARCACOES_POSSIVEIS = 5; 
	
	public Tabuleiro(int tamanho){
		mMatrizCelula = new Celula[tamanho][tamanho];
		mCelulasAtacadas = new Celula[tamanho][tamanho];
		PreencherTabuleiro(mMatrizCelula);
		//Por Default, cria o tabuleiro completo com as embarcacoes
		arrEmbarcacoes = new Embarcacao[QUANTIDADE_EMBARCACOES_POSSIVEIS];
		criarEmbarcacoes();
	}
	
	public Tabuleiro(int tamanho, boolean preencherComBarcos){
		mMatrizCelula = new Celula[tamanho][tamanho];
		mCelulasAtacadas = new Celula[tamanho][tamanho];
		PreencherTabuleiro(mMatrizCelula);
		if(preencherComBarcos){
			arrEmbarcacoes = new Embarcacao[QUANTIDADE_EMBARCACOES_POSSIVEIS];
			criarEmbarcacoes();
		}
	}
	
	private void PreencherTabuleiro(Celula[][] celulas) {
		for(int i = 0; i < celulas.length; i++){
			for(int j = 0; j < celulas[0].length; j++){
				celulas[i][j] = new Celula();
			}
		}
	}
	public Celula[][] getMatrizCelula() {
		return mMatrizCelula;
	}

	public void setMatrizCelula(Celula[][] mMatrizCelula) {
		this.mMatrizCelula = mMatrizCelula;
	}

	public Celula[][] getCelulasAtacadas() {
		return mCelulasAtacadas;
	}

	public void setCelulasAtacadas(Celula[][] mCelulasAtacadas) {
		this.mCelulasAtacadas = mCelulasAtacadas;
	}

	public boolean isTravaTabuleiro() {
		return bTravaTabuleiro;
	}

	public void setTravaTabuleiro(boolean bTravaTabuleiro) {
		this.bTravaTabuleiro = bTravaTabuleiro;
	}

	public boolean isTurno() {
		return bTurno;
	}

	public void setTurno(boolean bTurno) {
		this.bTurno = bTurno;
	}

	public Jogador getoJogador() {
		return oJogador;
	}

	public void setoJogador(Jogador oJogador) {
		this.oJogador = oJogador;
	}

	public Embarcacao[] getArrEmbarcacoes() {
		return arrEmbarcacoes;
	}

	public void setArrEmbarcacoes(Embarcacao[] arrEmbarcacoes) {
		this.arrEmbarcacoes = arrEmbarcacoes;
	}

	public boolean seTabuleiroTravado(Jogador jogador) {
		return jogador.getTabuleiroAtaque().isTravaTabuleiro();
	}
	
	public boolean seCelulaAtacada(Celula celula) {
		Celula obj = mCelulasAtacadas[celula.x][celula.y];
		if(obj != null)
		{
			//Celula celulaDefesa = mMatrizCelula[celula.x][celula.y];
			//return celulaDefesa.aTipoCelula != TipoCelula.AreaLivre; 
			return obj.aTipoCelula != TipoCelula.AreaLivre;
		}
		return  false;
	}
	
	public Celula encontrarCelula(int x, int y) throws IndexOutOfBoundsException {
			Celula objCelula = mMatrizCelula[x][y];
			return objCelula;
	}
	
	public Celula atacar(int x, int y){
		Celula celAtacada = encontrarCelula(x,y);
		mCelulasAtacadas[x][y] = celAtacada;
		
		switch(celAtacada.getTipoCelula())
		{
		case Agua:
			celAtacada.aTipoCelula = TipoCelula.Agua;
			break;
		case AreaLivre:
			celAtacada.aTipoCelula = TipoCelula.Agua;
			break;
		case Embarcacao:
			acertarEmbarcacao(celAtacada);
			break;
		}
		 
		
		
		return celAtacada;
	}
	private void acertarEmbarcacao(Celula celula) {
		// TODO Implementar com o código correto e refatorado
		for(int i = 0; i < arrEmbarcacoes.length; i++){
			Embarcacao barco = arrEmbarcacoes[i];
			Celula parteBarco = barco.getCelulaAtacada(celula);
			if(parteBarco != null){
				// TODO Fazer a lógica para quando um barco é acertado
			}
		}
	}
	
	public void ajustarEmbarcacoes(){
		for(int i = 0; i < arrEmbarcacoes.length; i++){
			Embarcacao barco = arrEmbarcacoes[i];
			barco.setVertical(i % 2 == 0);
			if(barco != null){
				Celula[] celulasBarco = barco.getListaCelulas();
				for(int j = 0; j < celulasBarco.length; j++){
					Celula celula = celulasBarco[j];
					mMatrizCelula[celula.x][celula.y] = celula;
				}				
			}
		}
	}
	

	private void criarEmbarcacoes() {
		Random randNum = new Random();
		int posx = randNum.nextInt(this.mMatrizCelula.length);
		int posy = randNum.nextInt(this.mMatrizCelula[0].length);
		int maxTentativas = 10000;
		for(int i = 0; i < arrEmbarcacoes.length && maxTentativas > 0; i++){			
		
			Embarcacao barco = gerarEmbarcacao(posx, posy, i+1);
			
			if(ValidarPosicaoEmbarcacao(barco, posx, posy)){
				barco.setPosicao(posx, posy);
				arrEmbarcacoes[i] = barco;
			}		
			else{
				//inverte a orientacao do barco
				barco.setVertical(!barco.estaVertical());
				//tenta validar de novo
				if(ValidarPosicaoEmbarcacao(barco, posx, posy)){
					barco.setPosicao(posx, posy);
					arrEmbarcacoes[i] = barco;
				}
				else{
					//Se não der mesmo, repete o passo
					i--; //decrementa o i para repetir o passo
					maxTentativas--;
					System.out.println("Tentativas:" + maxTentativas + " | Barco: " + barco.getNomeEmbarcacao());
				}
			}
			if(maxTentativas == 0){
				//throw new Exception("Tentativas de alocar o barco esgotadas");
				// sai do loop se ocorrer este caso
				System.out.println("Limite de tentativas excedidas");
				break;
			}			
			posx = randNum.nextInt(this.mMatrizCelula.length);
			posy = randNum.nextInt(this.mMatrizCelula[0].length);
		}
		
		repintarTabuleiro();
	}
	
	//Valida se a nova posição para o barco é válida (Se não está fora do tabuleiro ou sobrepondo de outro barco)
	public boolean ValidarPosicaoEmbarcacao(Embarcacao barco, int x, int y) {
		//incrementadores da posição que será validada para a embarcação
		int xInc = x;
		int yInc = y;
		try{
			Celula[] celulas = barco.getListaCelulas();
			//Verifica se as posições estão válidas
			for(int i = 0; i < celulas.length; i++){
				//Pega a embarcação daquela posição em verificação
				Embarcacao barcoDaCelula = this.getEmbarcacao(xInc, yInc);
				//Se tem algum barco naquela célula e não for o barco que estou movendo, retorna falso
				if(barcoDaCelula != null && !barcoDaCelula.equals(barco)){
					return false;
				}
				
				if(this.mMatrizCelula[xInc][yInc] == null)
					return false;
				if(xInc >= this.mMatrizCelula.length || yInc >= this.mMatrizCelula[0].length)
					return false;
				//Se o barco está na vertical, aumenta o Y para verificar a proxima celula vertical
				//senão aumenta o X para verificar a proxima celula horizontal
				if(barco.estaVertical())
				{ yInc++; }
				else
				{ xInc++; }
			}
		}
		catch(IndexOutOfBoundsException ex){
			//A embarcação ficará com alguma parte fora do tabuleiro
			//se cair aqui dentro
			//throw ex;
			return false;
		}
		

		//Seta a posição da frente do barco apenas se tiver válido
		//barco.setPosicao(x, y);
		//Só retorna TRUE se passar por toda a validação e não sair do método com alguma posição falsa
		return true;
	}
	
	private Embarcacao gerarEmbarcacao(int posx, int posy, int tamanho) {
		Embarcacao obj = new Embarcacao(tamanho);
		obj.setNomeEmbarcacao("Barco " + tamanho);
		obj.setPosicao(posx, posy);
		return obj;
	}

	public boolean isTodosBarcosAfundados() {
		
		for (Embarcacao barco : this.arrEmbarcacoes) {
			//se pelo menos 1 barco não estiver naufragado, retorna falso
			if(!barco.getNaufragado()){
				return false;
			}
		}
		
		return true;
	}

	public Embarcacao getEmbarcacao(int x, int y) {
		//Percorre as embarcações em busca das célula na posição esperada
		for(Embarcacao barco:this.arrEmbarcacoes){
			if(barco != null){
				Celula celula = barco.getCelula(x,y);
				//Se encontrar a célula em um barco, retorna este barco
				if(celula != null){
					return barco;
				}
			}
			
		}
		return null;
	}
	
	public void repintarTabuleiro(){
		//Limpa todas as células do tabuleiro (marca-as como água)
		for(int i = 0; i < this.mMatrizCelula.length; i++){
			for(int j = 0; j < this.mMatrizCelula[0].length; j++){
				this.mMatrizCelula[i][j].limpar();
			}
		}
		
		//Atribui cada célula da embarcacao nas celulas do tabuleiro (definitivas)
		//Essa "pintura" é importante para imprimir no cliente e enviar o tabuleiro serializado
		for(int i = 0; i < arrEmbarcacoes.length; i++){
			Embarcacao barco = arrEmbarcacoes[i];
			Celula[] celulasBarco = barco.getListaCelulas();
			for(int j = 0; j < celulasBarco.length; j++){
				int x = celulasBarco[j].x;
				int y = celulasBarco[j].y;
				mMatrizCelula[x][y] = celulasBarco[j];				
			}
		}
	}
	
	//TODO Método criado apenas para testes de visualização no console
	//excluir após interface do jogo estar pronta
	public void pintarTabuleiro(){
		int index = 0;
		Celula[][] celulasDef = this.getMatrizCelula();
		System.out.print("      ");
		for (int i = 1; i <= celulasDef.length; i++)
			System.out.print(i + "     ");

		System.out.print("\n");

		for (int i = 0; i < celulasDef.length; i++) {
			System.out.print((char) (index + 'A') + "   ");
			index++;

			for (int j = 0; j < celulasDef[0].length; j++) {
				if (celulasDef[i][j].getTipoCelula() == TipoCelula.Embarcacao && !this.seCelulaAtacada(celulasDef[i][j]))
					System.out.print("  @  |");
				if (celulasDef[i][j].getTipoCelula() == TipoCelula.Embarcacao && this.seCelulaAtacada(celulasDef[i][j]))
					System.out.print("  X  |");
				if (celulasDef[i][j].getTipoCelula() == TipoCelula.Agua)
					System.out.print("  O  |");
				if (celulasDef[i][j].getTipoCelula() == TipoCelula.AreaLivre)
					System.out.print("     |");
			}
			System.out.print("\n    ");

			for (int k = 0; k < celulasDef.length; k++)
				System.out.print("-----+");
			System.out.print("\n");
		}
	}
}
