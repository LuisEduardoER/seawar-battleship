package modelos;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.MulticastSocket;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import javax.swing.event.EventListenerList;

import exceptions.FullGameException;
import exceptions.GameException;

import utils.Parser;

import Comunicacao.Constantes;
import Comunicacao.DicionarioMensagem;
import Comunicacao.IMessageListener;
import Comunicacao.MessageReceiver;
import Comunicacao.MessageSender;
import Comunicacao.MulticastSender;
import Comunicacao.TipoMensagem;
import Events.ServerEvent;
import Events.ServerEventListener;
import Events.TipoEvento;

//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : @Seawar
//  @ File Name : Servidor.java
//  @ Date : @06/05/2011
//  @ Author : @Fernando
//
//

public class Servidor implements IMessageListener {
	private ExecutorService serverExecutor;
	ServerSocket serversocket; // Socket do servidor
	private boolean continuarRecebendoConexoes; //flag para receber ou não conexões novas
	int capacidade = Constantes.CAPACIDADE_JOGO; //quantidade de jogadores possiveis em um jogo
	int tamanhoTabuleiro = Constantes.TAMANHO_TABULEIRO; //numero de células do tabuleiro
	int idUltimoJogo = 1; //Variavel que é incrementada a cada jogo criado.
	
	private final int TOKEN_HEADER = 0; //indice do token correspondente a chave do cabeçalho
	private final int TOKEN_VALUE = 1; //indice do token correspondente ao valor
	
	//Define uma lista de eventos para a classe Servidor
	protected EventListenerList listenerList = new EventListenerList();

	public List<Jogo> aListaJogos;
	public List<Jogador> aListaJogadorOnline;
	public List<Jogador> aListaJogadorJogando;
	
	public Servidor(){
		aListaJogos = new ArrayList<Jogo>();
		aListaJogadorOnline = new ArrayList<Jogador>();
		aListaJogadorJogando = new ArrayList<Jogador>();
		serverExecutor = Executors.newCachedThreadPool();
		continuarRecebendoConexoes = true;
	}
	
	public void IniciarServidor(){
		try{
			//Cria socket para ouvir uma porta e conseguir manter até 100 conexões
			ServerSocket serversocket = new ServerSocket(Comunicacao.Constantes.SERVER_PORT, 100);
			
			while(continuarRecebendoConexoes){
				
				Socket clientSocket = serversocket.accept();
				
				serverExecutor.execute(new MessageReceiver(this, clientSocket));
				
				fireDisplayChangeEvent(new ServerEvent(String.format("Usuario conectado (%s)", clientSocket.getInetAddress().getHostAddress()),TipoEvento.DisplayAtualizado));
			}
		}
		catch(Exception ex){
			pararDeReceberConexoes();
			Log.gravarLog("Erro: " + ex.getMessage());
		}
		
	}
	
	public void pararDeReceberConexoes(){
		continuarRecebendoConexoes = false;
		serverExecutor.shutdown();
	}
	
	public List<Jogo> getListaJogos() {
		return aListaJogos;
	}
	
	public void setListaJogos(List<Jogo> listaJogos) {
		aListaJogos = listaJogos;
	}
	
	public List<Jogador> getListaJogadorOnline() {
		return aListaJogadorOnline;
	}
	
	public void setListaJogadorOnline(List<Jogador> listaJogadorOnline) {
		aListaJogadorOnline = listaJogadorOnline;
	}
	
	public void getListaJogadorJogando() {
	
	}
	
	public void setListaJogadorJogando(List<Jogador> listaJogadorJogando) {
	
	}
	
	public void adicionarJogo(Jogo objJogo) {
		aListaJogos.add(objJogo);
		fireDisplayChangeEvent(new ServerEvent(String.format("Novo Jogo Aberto (%s)", objJogo.getIdJogo()), TipoEvento.JogosAtualizados));
	}
	
	public void removerJogo(int jogoId) {
		if(jogoId <= 0)
			return;
		
		Jogo objRemover = encontrarJogoPorId(jogoId);	
		if(objRemover != null){
			aListaJogos.remove(objRemover);
			ServerEvent evt = new ServerEvent(String.format("Jogo%s Fechado (Motivo: Vazio)", jogoId), TipoEvento.JogosAtualizados);
			fireDisplayChangeEvent(evt);
			fireGamesListChangeEvent(evt);
		}
	}

	public void registrarLog(String log) {
		
		try {
			Log objLog = new Log();
			objLog.data = new Date();
			objLog.setTexto(log);
			//TODO: Criar o método de gravar log no objLog, pra ficar objLog.Gravar()
			
		} catch (Exception e) {
			e.printStackTrace();
		}
		
	}
	//Método deve ser executado em um intervalo determinado
	//para que o jogador envie um socket para atualizar o tempo dele online
	public void verificarJogador(Jogador objJogador) {
	
		if(! objJogador.isOnline()) //Quando não renovar o tempo, ele não deve mais estar jogando
		{
			derrubarJogador(objJogador);
		}
	}
	
	public void conectarJogador(Jogador objJogador){
		aListaJogadorOnline.add(objJogador);
		ServerEvent evt = new ServerEvent(objJogador, TipoEvento.JogadoresAtualizados);
		firePlayerListChangeEvent(evt);
	}
	
	public void derrubarJogador(Jogador objJogador) {
		//Dispara evento para dizer que a lista de jogadores foi alterada
		ServerEvent evt = new ServerEvent(objJogador, TipoEvento.JogadoresAtualizados);
		firePlayerListChangeEvent(evt);
	}

	@Override
	public void mensagemRecebida(String mensagem, Socket socketOrigem) {
		this.registrarLog(mensagem);
		//Divide a mensagem em tokens e trata ela para depois enviar apenas para o destinatario correto
		StringTokenizer tokens = new StringTokenizer(mensagem, Constantes.TOKEN_SEPARATOR);
		
		receberTokensMensagem(tokens, socketOrigem);
		
	}

	private boolean IsMulticastMessage(String mensagem) {
		boolean isMulticast = false;
		String[] lstCabecalhos = {
				Constantes.TOKEN_SEPARATOR+TipoMensagem.ConectarServidor
				,Constantes.TOKEN_SEPARATOR+TipoMensagem.DesconectarServidor
				,Constantes.TOKEN_SEPARATOR+TipoMensagem.JogoCriado
				,Constantes.TOKEN_SEPARATOR+TipoMensagem.JogadorTimeout
				//,Constantes.TOKEN_SEPARATOR+TipoMensagem.
				//,Constantes.TOKEN_SEPARATOR+TipoMensagem.ConectarServidor
				};
		if(mensagem.contains(Constantes.TOKEN_SEPARATOR)){
			int indiceFimCorte = mensagem.indexOf(Constantes.TOKEN_SEPARATOR, 3);
			indiceFimCorte = (indiceFimCorte > 0) ? indiceFimCorte : 1;
			String cabecalho = mensagem.substring(0, indiceFimCorte);
			for (int i = 0; i < lstCabecalhos.length; i++) {
				if(cabecalho.equalsIgnoreCase(lstCabecalhos[i])){
					isMulticast = true;
					break; //quebra o loop se o cabeçalho for de mensagem do tipo multicast
				}
			}
		}
		
		return isMulticast;
	}

	@Override
	public void receberTokensMensagem(StringTokenizer tokens, Socket socketOrigem) {
		List<String> lstTokens = new ArrayList<String>();
		
		
		//Transforma os tokens em lista
		while (tokens.hasMoreTokens()){
			String token = tokens.nextToken().trim();
			if(!token.isEmpty()){
				lstTokens.add(token);
			}
		}//fim da adatapcao da lista de tokens		
		
		TratarTokens(lstTokens,  socketOrigem);
	}


	
	private void TratarTokens(List<String> lstTokens, Socket socket) {
		if(lstTokens == null || lstTokens.isEmpty())
			return;
		
		String header = lstTokens.get(TOKEN_HEADER);
		if((Constantes.TOKEN_SEPARATOR+header).equalsIgnoreCase(Constantes.CONNECT_TOKEN)){
			ConectarJogadorNovo(lstTokens, socket);
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.EnviarListaJogadores.toString())){
			EnviarListaJogadores(lstTokens, socket);
		}
		else if((Constantes.TOKEN_SEPARATOR+header).equalsIgnoreCase(Constantes.DISCONNECT_TOKEN)){
			DesconectarJogador(lstTokens, socket);
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.SerChamadoPorJogador.toString())){
			ChamarJogadorParaJogar(lstTokens, socket);
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.EnviarListaJogos.toString())){
			EnviarListaJogosAbertos(lstTokens, socket);
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.EntrarJogo.toString())){
			ConectarJogadorEmJogo(lstTokens, socket);
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.SairDeJogo.toString())){
			DesconectarJogadorDeJogo(lstTokens, socket);
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.CriarJogo.toString())){
			CriarJogoComJogador(lstTokens, socket);
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.ChamarJogador.toString())){
			ChamarJogadorParaJogar(lstTokens, socket);
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.RespostaChamada.toString())){
			verificarRespostaChamadaParaJogar(lstTokens, socket);
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.Ping.toString())){
			AtualizaUltimoPingJogador(lstTokens, socket);
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.JogadorDesconectado.toString())){
			DesconectarJogador(lstTokens, socket);
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.JogadorTimeout.toString())){
			DesconectarJogador(lstTokens, socket);
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.JogoCriado.toString())){
			AtualizarListaJogos(lstTokens, socket);
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.NovoJogadorConectado.toString())){
			AtualizarListaJogadores(lstTokens, socket);
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.OponenteEntrou.toString())){
			LiberarTelaDeJogo(lstTokens, socket);
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.IniciarJogo.toString())){
			DesbilitarJogoParaNovasConexoes(lstTokens, socket);			
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.BarcosPosicionados.toString())){
			CarregarBarcosDoJogadorNoJogo(lstTokens, socket);
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.AtacarOponente.toString())){
			ProcessarAtaque(lstTokens, socket);
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.RespostaAtaque.toString())){
			//É uma mensagem que apenas o jogador receberá como feedback do ataque que realizou
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.ReceberAtaque.toString())){
			//É uma mensagem que apenas o jogador receberá quando o seu barco for atacado
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.EnviarMensagemOponente.toString())){
			EnviarMensagemSocktParaAdversario(lstTokens, socket);
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.ReceberMensagemOponente.toString())){
			//É uma mensagem que apenas o jogador receberá quando o oponente enviar uma mensagem
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.GanhouJogo.toString())){
			DefinirJogadorComoVencedor(lstTokens, socket);
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.PerdeuJogo.toString())){
			DefinirJogadorComoPerdedor(lstTokens, socket);
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.JogarComBot.toString())){
			AtivarBotComoOponenteParaJogador(lstTokens, socket);
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.ReceberListaJogadores.toString())){
			//Para Cliente receber e popular a lista de jogadores na tela dele
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.ReceberListaJogos.toString())){
			//Para o cliente receber e popular al ista de jogos na tela dele
		}
		else if(header.equalsIgnoreCase(Comunicacao.TipoMensagem.ReceberTabuleiroOponente.toString())){
			//mensagem que não será utilizada, pois o tabuleiro não será enviado para o cliente mais
		}
	}

	private void DesconectarJogadorDeJogo(List<String> lstTokens, Socket socket) {
		int idJogo = 0;
		
		for (String token : lstTokens) {
			String[] split = token.split(Constantes.VALUE_SEPARATOR);
			if(split[TOKEN_HEADER].equalsIgnoreCase("jogoid")){
				idJogo = Integer.parseInt(split[TOKEN_VALUE]);
			}
		}
		
		if(idJogo > 0){
			Jogo jogo = encontrarJogoPorId(idJogo);
			if(jogo != null){
				Jogador jogadorSair = jogo.EncontrarJogador(socket);
				Jogador adversario = jogo.EncontrarJogadorAdversario(jogadorSair);
				
				int posicaoJogadorEmJogo = jogo.getListaJogador().indexOf(jogadorSair);
				jogo.removerJogador(jogadorSair);
				aListaJogadorJogando.remove(jogadorSair);
				aListaJogadorOnline.add(jogadorSair);
				
				//Se agora o jogo estiver vazio, remove o jogo da lista
				if(jogo.isVazio())
					removerJogo(jogo.getIdJogo());
				else{
					//Se o jogo não ficou vazio com a saída do jogador, coloca-o como bot
					//para caso o jogador decida jogar contra um bot
					inicializarBotEmJogo(jogadorSair, posicaoJogadorEmJogo, jogo);
					

					//Após marcar o jogador como bot, avisa o adversário que ele saiu para decidir se quer jogar contra bot ou não
					String mensagemJogadorDesconectado = DicionarioMensagem.GerarMensagemPorTipo(TipoMensagem.JogadorDesconectado);
					mensagemJogadorDesconectado = String.format(mensagemJogadorDesconectado, jogo.getIdJogo(), jogadorSair.getLogin(), jogadorSair.getId_usuario());
					MessageSender messageSender = new MessageSender(adversario.getConexao().getSocket(), mensagemJogadorDesconectado);
					serverExecutor.execute(messageSender);
				}
				firePlayerListChangeEvent(new ServerEvent(aListaJogadorOnline, TipoEvento.JogadoresAtualizados));
			}
		}
	}

	private void verificarRespostaChamadaParaJogar(List<String> lstTokens, Socket socket) {
		String resposta = null;
		String nomeJogadorChamou = null;
		int idJogo = 0;
		for (String token : lstTokens) {
			String[] split = token.split(Constantes.VALUE_SEPARATOR);
			if(split[TOKEN_HEADER].equalsIgnoreCase("resposta")){
				resposta = split[TOKEN_VALUE];
			}
			else if(split[TOKEN_HEADER].equalsIgnoreCase("nomeChamou")){
				nomeJogadorChamou = split[TOKEN_VALUE];
			}
			else if(split[TOKEN_HEADER].equalsIgnoreCase("jogoid")){
				idJogo = Integer.parseInt(split[TOKEN_VALUE]);
			}
		}

		Jogador jogadorChamado = this.encontrarJogadorPorSocket(socket);
		Jogo jogo = this.encontrarJogoPorId(idJogo);
		Jogador jogadorChamou = jogo.EncontrarJogadorAdversario(jogadorChamado);
		if(resposta != null){
			if(Constantes.RESPOSTA_NEGATIVA.equalsIgnoreCase(resposta)){
				//TODO: alertar jogador sobre resposta negativa
				String mensagem = DicionarioMensagem.GerarMensagemPorTipo(TipoMensagem.RespostaChamada);
				mensagem = String.format(mensagem, idJogo, jogadorChamado.getLogin(), resposta);
				serverExecutor.execute(new MessageSender(jogadorChamou.getConexao().getSocket(), mensagem));

			}
			else{
				//TODO: alertar jogador sobre resposta positiva (se necessário, pq agora o jogador conecta no jogo se tiver resposta positiva)
				//ConectarJogadorEmJogo(lstTokens, socket);//Código comentado porque o client já faz isso
			}
		}
	}

	private void ChamarJogadorParaJogar(List<String> lstTokens, Socket socket) {
		String nomeChamado = null;
		Jogador jogadorChamou = this.encontrarJogadorPorSocket(socket);
		int idJogo = 0;
		for (String token : lstTokens) {
			String[] split = token.split(Constantes.VALUE_SEPARATOR);
			if(split[TOKEN_HEADER].equalsIgnoreCase("nome")){
				nomeChamado = split[TOKEN_VALUE];
			}
			else if(split[TOKEN_HEADER].equalsIgnoreCase("jogoid")){
				idJogo = Integer.parseInt(split[TOKEN_VALUE]);
			}
		}
		Jogador jogadorChamado = this.encontrarJogadorPorNome(nomeChamado);
		if(jogadorChamado != null){
			String mensagem = DicionarioMensagem.GerarMensagemPorTipo(TipoMensagem.SerChamadoPorJogador);
			mensagem = String.format(mensagem, idJogo, jogadorChamou.getLogin());
			serverExecutor.execute(new MessageSender(jogadorChamado.getConexao().getSocket(), mensagem));
		}
		else{
			//Jogador não está disponível para ser chamado, 
			//então avisa o jogador que chamou que o outro está indisponivel
			String mensagem = DicionarioMensagem.GerarMensagemPorTipo(TipoMensagem.RespostaChamada);
			mensagem = String.format(mensagem, idJogo, nomeChamado, "indisponivel");
			serverExecutor.execute(new MessageSender(socket, mensagem));
		}
	}


	private void EnviarListaJogosAbertos(List<String> lstTokens, Socket socket) {
		String jogos = aListaJogos.toString().replace("[", "").replace("]", "");
		String mensagem = DicionarioMensagem.GerarMensagemPorTipo(TipoMensagem.ReceberListaJogos);
		mensagem = String.format(mensagem, jogos);
		serverExecutor.execute(new MessageSender(socket, mensagem)); 
	}

	private void AtivarBotComoOponenteParaJogador(List<String> lstTokens,Socket socketEnviou) {
		int jogoId = -1;
		for(String token : lstTokens){
			String[] split = token.split(Constantes.VALUE_SEPARATOR);
			if(split[TOKEN_HEADER].equalsIgnoreCase("jogoid")){
				jogoId = Integer.parseInt(split[TOKEN_VALUE]);
			}
		}
		//Recupera o jogo que conterá o bot
		Jogo jogo = this.encontrarJogoPorId(jogoId);
		if(jogo != null){
			//Encontra o jogador que solicitou o bot
			Jogador jogador = jogo.EncontrarJogador(socketEnviou);
			if(jogador != null){
				//Define o adversário do jogador como um bot
				Jogador adversario = jogo.EncontrarJogadorAdversario(jogador);
				//Se o adversario for um bot e for a vez dele jogar, ele jogará
				if(adversario.isBot() && adversario.isMinhaVez()){
					Bot bot = (Bot)adversario;
					serverExecutor.execute(bot);
				}
				//bot.setOffline();
				//bot.setIsBot(true);
				fireDisplayChangeEvent(
						new ServerEvent(String.format("Jogador %s ativou o bot no lugar do jogador %s", jogador.getLogin(), /*bot.getLogin()*/"adversário"), TipoEvento.DisplayAtualizado)
						);
				
				
			}
		}		
		
	}

	private void DefinirJogadorComoPerdedor(List<String> lstTokens, Socket socketEnviou) {
		int jogoId = -1;
		for(String token : lstTokens){
			String[] split = token.split(Constantes.VALUE_SEPARATOR);
			if(split[TOKEN_HEADER].equalsIgnoreCase("jogoid")){
				jogoId = Integer.parseInt(split[TOKEN_VALUE]);
			}
		}
		//Encontra o jogo da pessoa que perdeu
		Jogo jogo = this.encontrarJogoPorId(jogoId);
		if(jogo != null){
			//Recupera o jogador que perdeu o jogo
			Jogador jogador = jogo.EncontrarJogador(socketEnviou);
			if(jogador != null){
				//Atualiza a pontuação do cara (200 pontos por perder?)
				int pontos = 0;
				//Verifica quantos barcos ele afundou
				for(Embarcacao barco : jogador.getTabuleiroAtaque().getArrEmbarcacoes()){
					if(barco.getNaufragado()){
						//pontua pelo valor do barco
						pontos += barco.getValorEmbarcacao();
					}else {
						for(Celula celulaBarco : barco.getListaCelulas()){							
							//Pontua de acordo com as células que ele acertou
							pontos += (celulaBarco.getTipoCelula() == TipoCelula.Embarcacao) ? barco.getValorEmbarcacao()/barco.getTamanho() : 0;
						}
					}
				}
				//Define a pontuação calculada com base nos barcos afundados e partes acertadas
				jogador.setPontuacao(pontos);
				
				//Encontra o adversário do jogador
				Jogador adversario = jogo.EncontrarJogadorAdversario(jogador);
				//Declara o jogador como perdedor e o adversário como ganhador
				this.declararVencedor(jogo, adversario);
				this.declararPerdedor(jogo, jogador);
				//Dispara evento para exibir a mensagem no servidor
				fireDisplayChangeEvent(
						new ServerEvent(String.format("%s ganhou do %s no jogo %s", adversario.getLogin(), jogador.getLogin(), jogo.getIdJogo()), TipoEvento.DisplayAtualizado)
						);
				
			}
		}			
	}

	/*
	 * Declara o jogador que enviou a mensagem como um vencedor 
	 */
	private void DefinirJogadorComoVencedor(List<String> lstTokens, Socket socketEnviou) {
		int jogoId = -1;
		for(String token : lstTokens){
			String[] split = token.split(Constantes.VALUE_SEPARATOR);
			if(split[TOKEN_HEADER].equalsIgnoreCase("jogoid")){
				jogoId = Integer.parseInt(split[TOKEN_VALUE]);
			}
		}
		
		Jogo jogo = this.encontrarJogoPorId(jogoId);
		if(jogo != null){
			Jogador jogador = jogo.EncontrarJogador(socketEnviou);
			if(jogador != null){

				Jogador adversario = jogo.EncontrarJogadorAdversario(jogador);
				
//				//Atualiza a pontuação do cara se nao for BOT (200 pontos por perder?)
//				int pontos = 0;
//				//Verifica quantos barcos ele afundou no campo do adversário
//				for(Embarcacao barco : this.getTabuleiroDefesa().getArrEmbarcacoes()){
//					if(barco != null){
//						if(barco.getNaufragado()){
//							//pontua pelo valor do barco
//							pontos += barco.getValorEmbarcacao();
//						}else {
//							for(Celula celulaBarco : barco.getListaCelulas()){							
//								//Pontua de acordo com as células que ele acertou
//								pontos += (celulaBarco.getTipoCelula() == TipoCelula.Embarcacao && celulaBarco.isAtirada()) ? barco.getValorEmbarcacao()/barco.getTamanho() : 0;
//							}
//						}
//					}
//				}
				
				this.declararVencedor(jogo, jogador);
				this.declararPerdedor(jogo, adversario);
				try{
				jogador.gravarPontuacao(adversario);
				adversario.gravarPontuacao(jogador);
				}
				catch(Exception e){
				 Log.gravarLog(e.getMessage());
				}
				fireDisplayChangeEvent(
						new ServerEvent(String.format("%s ganhou do %s no jogo %s", jogador.getLogin(), adversario.getLogin(), jogo.getIdJogo()), TipoEvento.DisplayAtualizado)
						);
				enviarMensagemListaAtualizada(jogador);
			}
		}
		
	}
	
	private void declararVencedor(Jogo jogo,Jogador vencedor) {
		//Define o vencedor no id do usuário
		//this.jogoCorrente.declaraJogadorVencedor(vencedor.getId_usuario());
		jogo.setCodJogadorVencedor(vencedor.getId_usuario());
		jogo.encerrarJogo();

		//Envia mensagem para o jogador vencedor, caso este não seja bot
		if(!vencedor.isBot()){
			//Recoloca o jogador na lista
			setJogadorOnline(vencedor);
			
			//Envia para o usuário que ele venceu o jogo
			String mensagem = DicionarioMensagem.GerarMensagemPorTipo(TipoMensagem.GanhouJogo);
			String mensagemEnviar = String.format(mensagem, jogo.getIdJogo(), vencedor.getLogin());
			MessageSender sender = new MessageSender(vencedor.getConexao().getSocket(), mensagemEnviar);
			serverExecutor.execute(sender);
		}
		else{
			Bot bot = (Bot)vencedor;
			bot.dispose();
		}
	}

	private void declararPerdedor(Jogo jogo, Jogador perdedor) {
		//Define o vencedor no id do usuário
		jogo.encerrarJogo();

		//Envia mensagem para o perdedor se ele não for bot
		if(!perdedor.isBot()){
			//Recoloca o jogador na lista
			setJogadorOnline(perdedor);
			
			//Envia para o usuário que ele venceu o jogo
			String mensagem = DicionarioMensagem.GerarMensagemPorTipo(TipoMensagem.PerdeuJogo);
			String mensagemEnviar = String.format(mensagem, jogo.getIdJogo(), perdedor.getLogin());
			MessageSender sender = new MessageSender(perdedor.getConexao().getSocket(), mensagemEnviar);
			serverExecutor.execute(sender);
		}
		else{
			Bot bot = (Bot)perdedor;
			bot.dispose();
		}
	}

	private void ProcessarAtaque(List<String> lstTokens, Socket socketEnviou) {
		boolean venceuJogo = false;	
		int jogoId = -1;
		for (String token : lstTokens) {
			String[] split = token.split(Constantes.VALUE_SEPARATOR);
			if(split[TOKEN_HEADER].equalsIgnoreCase("jogoid")){
				jogoId = Integer.parseInt(split[TOKEN_VALUE]);
			}
		}
		Celula celula = Parser.ConverteCelula(lstTokens);
		Jogo jogo = this.encontrarJogoPorId(jogoId);
		if(celula != null && jogo != null){
			Jogador jogador = encontrarJogadorPorIpEmJogo(jogo, socketEnviou);				
		
			Jogador adversario = encontrarAdversarioEmJogo(jogo, jogador);
			Tabuleiro tabuleiroAdversario = adversario.getTabuleiroDefesa();
			celula = tabuleiroAdversario.atacar(celula.x, celula.y);
			//Troca as flags da vez de quem atacou e de quem pode atacar
			jogador.setMinhaVez(false);
			adversario.setMinhaVez(true);
			if(!adversario.isBot()){
			//Envia ataque para o cliente que foi atacado (se não for bot)
			Socket clientSocketAtacado = adversario.getConexao().getSocket();
			String mensagemOriginal = DicionarioMensagem.GerarMensagemPorTipo(TipoMensagem.ReceberAtaque);
			String mensagemAtaque = String.format(mensagemOriginal, jogoId, celula.x, celula.y);
			serverExecutor.execute(new MessageSender(clientSocketAtacado, mensagemAtaque));
			}
			
			venceuJogo = tabuleiroAdversario.isTodosBarcosAfundados();
			
			if(!jogador.isBot())
			{
				//Se o jogador que atacou não for bot
				//Envia resposta sobre a célula que ele acertou
				String mensagemResposta = DicionarioMensagem.GerarMensagemPorTipo(TipoMensagem.RespostaAtaque);
				//TODO: Fzer esta mensagem enviar se o barco foi afundado ou não :)
				
				Embarcacao barcoAcertado = tabuleiroAdversario.getEmbarcacao(celula.x, celula.y);
				String nomeBarco = "";
				boolean afundouBarco = false;
				if(barcoAcertado != null){ 
					nomeBarco = barcoAcertado.getNomeEmbarcacao();
					afundouBarco = barcoAcertado.getNaufragado();
					//imprime na tela do servidor qual barco foi acertado
					String mensagemExibir = String.format("%s acertou o barco %s de %s. %s", jogador.getLogin(), nomeBarco, adversario.getLogin(), ((afundouBarco)?"***Barco Naufragado***":""));
					fireDisplayChangeEvent(new ServerEvent(mensagemExibir, TipoEvento.DisplayAtualizado));
				}
				String mensagemFormatada = String.format(mensagemResposta,jogo.getIdJogo(), celula.x, celula.y, celula.getTipoCelula().toString(), 0, nomeBarco, afundouBarco); 
				//ordem 0 pq eu não sei ainda como reconhecer qual parte do barco ele acertou
				Socket clientSocket = jogador.getConexao().getSocket();
				
				serverExecutor.execute(new MessageSender(clientSocket, mensagemFormatada));
			}
			
			//Caso o adversário seja um bot, inicia a ação do contra-ataque, após enviar para o jogador a resposta do ataque dele.
			if(adversario.isBot()){
				//TODO: Implementar a lógica de ataque do bot aqui
				Bot objBot = (Bot)(adversario);
				serverExecutor.execute(objBot);
			}
			//Se o jogador venceu o jogo com esse ataque, informa os 2 jogadores (exceto se um deles for bot)
			if(venceuJogo){
				//Limpa os tokens recebidos e adiciona apenas o que interessa
				//para que a mensagem de vencedor seja procesada
				lstTokens.clear();
				lstTokens.add(String.format("%s%s%s", "jogoid", Constantes.VALUE_SEPARATOR, jogo.getIdJogo()));
				//Define o jogador atacante como vencedor da partida
				DefinirJogadorComoVencedor(lstTokens, socketEnviou);
				
				//Remove o jogo da lista de jogos
				aListaJogos.remove(jogo);
				fireGamesListChangeEvent(new ServerEvent(aListaJogos, TipoEvento.JogosAtualizados));
			}
		}		
	}
	
	private void EnviarMensagemSocktParaAdversario(List<String> lstTokens, Socket socket) {
		// TODO Auto-generated method stub
		
	}

	private void CarregarBarcosDoJogadorNoJogo(List<String> lstTokens, Socket socket) {
		int jogoId = -1;//key:value;key2:value2
		Object tabuleiroObject = null;
		for(String token : lstTokens){
			String[] split = token.split(Constantes.VALUE_SEPARATOR);
			if(split[0].equalsIgnoreCase("jogoid")){
				jogoId = Integer.parseInt(split[1]);
			}
			if(split[0].equalsIgnoreCase("tabuleiro")){
				try {
					tabuleiroObject = Parser.StringParaObjeto(split[1]);
				} catch (IOException e) {
					e.printStackTrace();
					fireDisplayChangeEvent(new ServerEvent("Não foi recebido uma string válida", TipoEvento.DisplayAtualizado));
				} catch (ClassNotFoundException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}
		//Carrega o jogo a partir do ID enviado pelo socket
		Jogo jogo = this.encontrarJogoPorId(jogoId);
		if(jogo != null){
			//Encontra o jogador que enviou o socket
			Jogador jogador = jogo.EncontrarJogador(socket);
			if(jogador != null){
				//Converte o tabuleiro serializado em um tabuleiro no servidor
				Tabuleiro tabuleiro = (Tabuleiro)tabuleiroObject;  //Parser.ConverteTabuleiro(lstTokens);
//				Embarcacao[] barcos = (Embarcacao[])tabuleiroObject;
				//Carrega este tabuleiro como o tabuleiro de defesa deste jogador
				jogador.setTabuleiroDefesa(tabuleiro);
//				jogador.getTabuleiroDefesa().setArrEmbarcacoes(barcos);
				//dispara o evento que envia a mensagem que o tabuleiro foi recebido
				fireDisplayChangeEvent(
						new ServerEvent(String.format("Recebido tabuleiro de %s", jogador.getLogin()), TipoEvento.DisplayAtualizado)
						);
				//Marca o jogador como "pronto", assim o servidor sabe que este jogador
				//está pronto para jogar
				jogador.setPronto(true);
			}
			Jogador adv = jogo.EncontrarJogadorAdversario(jogador);
			if(adv == null){
				//TODO:NoEnemyException
				//Informa que o jogador X não tem adversários para receber a mensagem
				//de que ele já está com o tabuleiro pronto
				fireDisplayChangeEvent(
						new ServerEvent(String.format("%s não possui adversários para informar que está pronto", jogador.getLogin()), TipoEvento.DisplayAtualizado)
						);
				return; //para de executar o método
			}
			enviarAvisoJogadorPronto(jogo, jogador, adv);
		}
		
		//Inicia a partida quando Todos (2) jogadores enviarem os tabuleiros
		if(jogo.jogadoresProntos()){
			//Chama o método que inicia a partida do jogo
			this.iniciarPartida(jogo);				
		}
	}

	private void enviarAvisoJogadorPronto(Jogo jogo, Jogador jogador,
			Jogador adv) {
		//Envia mensagem para o inimigo falando o ID do jogo, o nome do adv q posicionou o barco e o status de OK
		String mensagem = DicionarioMensagem.GerarMensagemPorTipo(TipoMensagem.BarcosOponentePosicionados);				
		String msgEnviar = String.format(mensagem, jogo.getIdJogo(), jogador.getLogin(), "OK");				
		MessageSender msgAdv = new MessageSender(adv.getConexao().getSocket(),msgEnviar);
		serverExecutor.execute(msgAdv);
	}

	private void DesbilitarJogoParaNovasConexoes(List<String> lstTokens, Socket socket) {
		//Remover o jogo da lista de jogos disponiveis. (Apenas na lista de jogos em andamento, se tiver)
		for (String token : lstTokens) {
			String[] split = token.split(Constantes.VALUE_SEPARATOR);
			if (split[TOKEN_HEADER].equalsIgnoreCase("jogoid")) {
				
			}
		}
	}

	private void LiberarTelaDeJogo(List<String> lstTokens, Socket socket) {
		// TODO Auto-generated method stub
		
	}

	private void AtualizarListaJogadores(List<String> lstTokens, Socket socket) {
		// TODO Auto-generated method stub
		
	}

	private void AtualizarListaJogos(List<String> lstTokens, Socket socket) {
		// TODO Auto-generated method stub
		
	}

	private void AtualizaUltimoPingJogador(List<String> lstTokens,Socket socket) {
		// TODO Auto-generated method stub
		
	}

	private void CriarJogoComJogador(List<String> lstTokens, Socket socket) {
		
		Jogador jogadorCriador = this.encontrarJogadorPorSocket(socket);
		if(jogadorCriador != null){
			Jogo newGame = new Jogo(idUltimoJogo++, capacidade);
			try {
				newGame.AdicionarJogador(jogadorCriador);
				aListaJogos.add(newGame);
				aListaJogadorOnline.remove(jogadorCriador);
				aListaJogadorJogando.add(jogadorCriador);
				fireDisplayChangeEvent(
						new ServerEvent(String.format("%s criou o jogo id: %d", jogadorCriador.getLogin(), (idUltimoJogo-1)), TipoEvento.DisplayAtualizado)
				);
				fireGamesListChangeEvent(new ServerEvent(aListaJogos, TipoEvento.JogosAtualizados));
				
				//Informa o jogador que o jogo foi criado e ele foi inserido dentro do mesmo
				String msgEntrouJogo = DicionarioMensagem.GerarMensagemPorTipo(TipoMensagem.EntrarJogo);
				String msgEntrouJogoEnviar = String.format(msgEntrouJogo, newGame.getIdJogo(), jogadorCriador.getLogin(), newGame.getListaJogador().indexOf(jogadorCriador));
				MessageSender sender = new MessageSender(jogadorCriador.getConexao().getSocket(), msgEntrouJogoEnviar);
				serverExecutor.execute(sender);
				
				//Envia mensagem multicast para todos os jogadores de que o jogo foi criado
				String msgJogoCriado = DicionarioMensagem.GerarMensagemPorTipo(TipoMensagem.JogoCriado);
				msgJogoCriado = String.format(msgJogoCriado, newGame.getIdJogo(), jogadorCriador.getLogin());
				MulticastSender senderMulticast = new MulticastSender(msgJogoCriado);
				serverExecutor.execute(senderMulticast);
			} 
			catch (FullGameException e) {
				Log.gravarLog("Erro ao adicionar jogador em jogo que ele criou.");
			}
		}
	}

	//Conecta um jogador EM UM JOGO
	private void ConectarJogadorEmJogo(List<String> lstTokens, Socket socket) {
		int jogoId = -1;
		for (String token : lstTokens) {
			String[] split = token.split(Constantes.VALUE_SEPARATOR);
			if(split[TOKEN_HEADER].equalsIgnoreCase("jogoid")){
				jogoId = Integer.parseInt(split[TOKEN_VALUE]);
			}
		}
		Jogo jogo = encontrarJogoPorId(jogoId);
		//Se não encontrar o jogo, não faz nada
		if(jogo == null){			
			return;
		}
		
		//Se encontrar, conecta o jogador naquele jogo
		Jogador jogador = encontrarJogadorPorSocket(socket);
		if(jogador != null){
			try {
				String tokensJogadoresJogando="";
				//Se o jogador está em outro jogo, retira-o do jogo e remove o jogo se ficar vazio
				if(jogador.getJogoId() != jogoId){
					Jogo jogoRemover = encontrarJogoPorId(jogador.getJogoId());
					if(jogoRemover != null){
						jogoRemover.removerJogador(jogador);
						if(jogoRemover.isVazio()){
							removerJogo(jogoRemover.getIdJogo());
						}
					}
				}
				
				if(!jogo.isVazio()){
					//Se o jogo não estiver vazio, envia mensagem para os jogadores de plantão que mais 1 jogador entrou no jogo na última posição
					for(Jogador jogadorAguardando : jogo.getListaJogador()){
						String mensagem = DicionarioMensagem.GerarMensagemPorTipo(TipoMensagem.OponenteEntrou);
						String mensagemEnviar = String.format(mensagem, jogo.getIdJogo(), jogador.getLogin(), jogo.getListaJogador().size());
						MessageSender sender = new MessageSender(jogadorAguardando.getConexao().getSocket(), mensagemEnviar);
						serverExecutor.execute(sender);
						
						tokensJogadoresJogando += String.format("%s%s%s%s", Constantes.TOKEN_SEPARATOR, "jogador", Constantes.VALUE_SEPARATOR, jogadorAguardando.getLogin());
					}
				}
				jogador.setOnline();
				//Se o jogador não tiver nome, utilizará "Player" e a posição dele na lista como identificador
				if(jogador.getLogin().isEmpty())
					jogador.setLogin("Player"+(aListaJogadorJogando.size()+1));
				
				jogo.AdicionarJogador(jogador); //Esta adição causa exception se o jogo estiver lotado
				
				//Adiciona o jogador à lista de quem tá jogando, apenas se o jogador for adicionado no jogo antes
				setJogadorEmJogo(jogador);
				
				//Dispara o evento que informa o que deve-se imprimir na tela
				fireDisplayChangeEvent(new ServerEvent(String.format("%s adicionado ao jogo(%s)", jogador.getLogin(), jogo.getIdJogo()), TipoEvento.DisplayAtualizado));
				firePlayerListChangeEvent(new ServerEvent(aListaJogadorJogando, TipoEvento.JogadoresAtualizados));				
				
				//também informa o jogador qual a posição dele na lista de jogadores, concatenando também com tokens dos nomes de jogadores que estão online
				String msgEntrouJogo = DicionarioMensagem.GerarMensagemPorTipo(TipoMensagem.EntrarJogo);
				String msgEntrouJogoEnviar = String.format(msgEntrouJogo, jogo.getIdJogo(), jogador.getLogin(), jogo.getListaJogador().indexOf(jogador)) + tokensJogadoresJogando;
				MessageSender sender = new MessageSender(jogador.getConexao().getSocket(), msgEntrouJogoEnviar);
				serverExecutor.execute(sender);
				
			} catch (FullGameException e) {
				//Dispara o evento para imprimir na tela do servidor quando houver problemas
				String mensagem = String.format("Não foi possível conectar o jogador %s ao jogo(%s)\nMotivo:%s", jogador.getLogin(), jogo.getIdJogo(), e.getMessage()); 
				Log.gravarLog(mensagem);				
				fireDisplayChangeEvent(new ServerEvent(mensagem, TipoEvento.DisplayAtualizado));
				return; //cai fora do método se o jogo estiver cheio
			}catch(Exception e){
				Log.gravarLog(e.getMessage());
			}
			
			//Se o jogo está lotado agora, envia o comando para os jogadores que podem iniciar o posicionamento ou o jogo
			if(jogo.isLotado()){		

				//Cria um tabuleiro para cada jogador
				for(Jogador jogadorEmjogo : jogo.getListaJogador()){
					jogadorEmjogo.setTabuleiroDefesa(new Tabuleiro(tamanhoTabuleiro));
					jogadorEmjogo.setTabuleiroAtaque(new Tabuleiro(tamanhoTabuleiro, false));
					jogadorEmjogo.setJogoId(jogo.getIdJogo());
					
					String mensagemIniciar = DicionarioMensagem.GerarMensagemPorTipo(TipoMensagem.IniciarJogo);
					setJogadorEmJogo(jogadorEmjogo);
				}
				
				this.iniciarPosicionamentos(jogo);
			}			
		}
	}

	private void setJogadorEmJogo(Jogador jogadorEmjogo) {
		aListaJogadorOnline.remove(jogadorEmjogo);
		
		if(!aListaJogadorJogando.contains(jogadorEmjogo))
			aListaJogadorJogando.add(jogadorEmjogo);
		
	}
	private void setJogadorOnline(Jogador jogadorOnline) {
		aListaJogadorJogando.remove(jogadorOnline);
		
		if(!aListaJogadorOnline.contains(jogadorOnline))
			aListaJogadorOnline.add(jogadorOnline);		
	}
	

	private void DesconectarJogador(List<String> lstTokens, Socket socketEnviou) {
		Jogador jogador = this.encontrarJogadorPorSocket(socketEnviou);
		int posicaoJogadorEmJogo = 0;
		//Jogador jogador = EncontrarJogadorPorIp(ipEnviou);
		if(jogador == null){
			Log.gravarLog(String.format("Jogador sob IP: %s, não foi localizado", socketEnviou.getInetAddress().getHostAddress()));
			return;
		}
		//Se o carinha estava jogando, encontra o jogo e remove-o do jogo
		int idJogoJogando = jogador.getJogoId();
		Jogo jogo = encontrarJogoPorId(idJogoJogando);
		if(jogo != null){
			posicaoJogadorEmJogo = jogo.getListaJogador().indexOf(jogador);
			jogo.removerJogador(jogador);
			aListaJogadorJogando.remove(jogador);
			//Se agora o jogo estiver vazio, remove o jogo da lista
			if(jogo.isVazio() || posicaoJogadorEmJogo == 0)
				removerJogo(idJogoJogando);
			else{
				//Se o jogo não ficou vazio com a saída do jogador, coloca-o como bot
				//para caso o jogador decida jogar contra um bot
				inicializarBotEmJogo(jogador, posicaoJogadorEmJogo, jogo);
			}
		}
		if(jogador.setOffline()){
			//ficou offline por bem :)
		}
		else{
			this.derrubarJogador(jogador);
		}
		
		aListaJogadorOnline.remove(jogador);
		//Dispara eventos para a UI ser atualizada
		firePlayerListChangeEvent(new ServerEvent(aListaJogadorOnline, TipoEvento.JogadoresAtualizados));
		fireDisplayChangeEvent(new ServerEvent(String.format("%s desconectou",jogador.getLogin()), TipoEvento.DisplayAtualizado));
		
		//Após remover o jogador de todos os lugares e avisar a UI que ele foi removido, avisa os outros jogadores por multicast
		String mensagemJogadorDesconectado = DicionarioMensagem.GerarMensagemPorTipo(TipoMensagem.JogadorDesconectado);
		mensagemJogadorDesconectado = String.format(mensagemJogadorDesconectado, idJogoJogando, jogador.getLogin(), jogador.getId_usuario());
		MulticastSender multicastSender = new MulticastSender(mensagemJogadorDesconectado);
		serverExecutor.execute(multicastSender);
	}

	private void inicializarBotEmJogo(Jogador jogador,
			int posicaoJogadorEmJogo, Jogo jogo) {
		
		Bot objBot;
		// Instancia um novo para ser o bot
		objBot = new Bot(new Jogador(new Socket()),this);
		objBot.setMinhaVez(jogador.isMinhaVez());
		objBot.setLogin(jogador.getLogin());
		objBot.setPronto(jogador.isPronto());	
		objBot.setTabuleiroDefesa(jogador.getTabuleiroDefesa());
		objBot.setTabuleiroAtaque(jogador.getTabuleiroAtaque());
		
		Jogador adversario = jogo.EncontrarJogadorAdversario(jogador);
		objBot.setTabuleiroAtaque(adversario.getTabuleiroDefesa());
		objBot.getTabuleiroAtaque().setMatrizCelula(adversario.getTabuleiroDefesa().getMatrizCelula());
		try {
			jogo.AdicionarJogador(objBot, posicaoJogadorEmJogo);
			if(!objBot.isPronto()){
				enviarAvisoJogadorPronto(jogo, objBot, adversario);
				objBot.setPronto(true);
			}
		} catch (GameException e) {
			e.printStackTrace();
			Log.gravarLog("Não foi possível adicionar BOT ao jogo "+jogo.getIdJogo());
		}
	}
	
	private Jogador encontrarJogadorPorSocket(Socket socketJogador) {
		//Procura na lista de jogadores online atoa
		for (Jogador jogador : aListaJogadorOnline) {
			if(jogador.getConexao().socket == socketJogador){
				return jogador;
			}
		}
		//Procura na lista de jogadores jogando
		for (Jogador jogador : aListaJogadorJogando) {
			if(jogador.getConexao().socket == socketJogador){
				return jogador;
			}
		}
		//Procura nos jogos se não tiver na lista de jogadores online e nem jogando, procura dentro de cada jogo hosteado
//		for (Jogo jogo : aListaJogos) {
//			jogadorEncontrado = jogo.EncontrarJogador(socketJogador);
//			if(jogadorEncontrado != null){
//				return jogadorEncontrado;
//			}
//		}
		//retorna nulo se não encontrar
		return null;
	}

	private Jogo encontrarJogoPorId(int jogoId) {
		Jogo objRemover = null;		
		for(Jogo obj : aListaJogos){
			if(obj.getIdJogo() == jogoId){
				objRemover = obj;
				break;
				}
		}
		return objRemover;
	}
	
	/*Método utilizado para remover os jogos que não possuem mais jogadores*/
//	private void RemoverJogosVazios() {
//		for (int i = 0; i < aListaJogos.size(); i++) {
//			Jogo jogo =aListaJogos.get(i); 
//			if(jogo.isVazio()){
//				removerJogo(jogo.getIdJogo());
//			}
//		}
//	}

	private void EnviarListaJogadores(List<String> lstTokens, Socket socket) {
		String jogadores = aListaJogadorOnline.toString().replace("[", "").replace("]", "");
		String mensagem = DicionarioMensagem.GerarMensagemPorTipo(TipoMensagem.ReceberListaJogadores);
		mensagem = String.format(mensagem, jogadores);
		serverExecutor.execute(new MessageSender(socket, mensagem)); 
	}

	//Conecta o jogador NO SERVIDOR
	private void ConectarJogadorNovo(List<String> lstTokens, Socket socket) {
		Jogador obj = new Jogador(socket);
		for (String token : lstTokens) {
			String[] split = token.split(Constantes.VALUE_SEPARATOR);
			if(split[TOKEN_HEADER].equalsIgnoreCase("login")){					
				obj.setLogin(split[TOKEN_VALUE]);
			}
			else if(split[TOKEN_HEADER].equalsIgnoreCase("senha")){
				obj.setSenha(split[TOKEN_VALUE]);
			}
		}
		//Usuario usuarioValidado = Usuario.logar(obj.getLogin(), obj.getSenha());
		//if(usuarioValidado != null ){
		if(true){
			//obj.carregarDadosUsuario(usuarioValidado);
			//obj.setId_usuario(usuarioValidado.getId_usuario());
			//obj.setPontuacao(usuarioValidado.getPontuacao());
			aListaJogadorOnline.add(obj);
			//informa o jogador que ele foi conectado com sucesso!
			String msgConectado = DicionarioMensagem.GerarMensagemPorTipo(TipoMensagem.ConectarServidor);
			msgConectado = String.format(msgConectado, obj.getLogin(), ""); //Não repassa a senha para o outro lado
			MessageSender send = new MessageSender(obj.getConexao().getSocket(), msgConectado);
			serverExecutor.execute(send);
			//Atualiza a lista de jogadores online
			firePlayerListChangeEvent(new ServerEvent(aListaJogadorOnline, TipoEvento.JogadoresAtualizados));
			fireDisplayChangeEvent(new ServerEvent(String.format("%s conectou",obj.getLogin()), TipoEvento.DisplayAtualizado));
			enviarMensagemListaAtualizada(obj);
			}
		
	}

	private void enviarMensagemListaAtualizada(Jogador obj) {
		//Envia a mensagem multicast pra todos os jogadores falando que fulano conectou-se no servidor
		String msgMulticast = DicionarioMensagem.GerarMensagemPorTipo(TipoMensagem.NovoJogadorConectado);
		msgMulticast = String.format(msgMulticast, obj.getLogin());
		MulticastSender multicast = new MulticastSender(msgMulticast);
		serverExecutor.execute(multicast);
	}
	//Permite que os jogadores possam posicionar suas embarcações
	private void iniciarPosicionamentos(Jogo jogo) {
		fireDisplayChangeEvent(new ServerEvent("Jogo criado, aguardando posicionamento de frotas",TipoEvento.DisplayAtualizado));
		//faz o estado de "pronto" dos jogadores ficar em falso
		//para indicar quando posicionaram ou não seus barcos
		//PS: no caso, quando o servidor receber o tabuleiro
		for(Jogador jogador : jogo.getListaJogador()){
			jogador.setPronto(false);
		}
		
	}
	private Jogador encontrarAdversarioEmJogo(Jogo jogo, Jogador jogador) {

		Jogador adversario = null;
		if(jogador != null && jogo != null){
			return jogo.EncontrarJogadorAdversario(jogador);
		}
		return adversario;
	}
	
	private void iniciarPartida(Jogo jogoIniciar) {
		for(Jogador jogador : aListaJogadorJogando){
			String mensagemIniciar = DicionarioMensagem.GerarMensagemPorTipo(TipoMensagem.IniciarJogo);
			//Mensagem do tipo iniciar jogo, apenas recebe o jogoId
			String mensagemFormatada = String.format(mensagemIniciar, jogoIniciar.getIdJogo());
			
			MessageSender enviador = new MessageSender(jogador.getConexao().getSocket(), mensagemFormatada);
			//Envia a mensagem para o jogador que está aguardando o inicio da partida
			serverExecutor.execute(enviador);
		}			
		fireDisplayChangeEvent(new ServerEvent("Iniciando a partida do jogo",TipoEvento.DisplayAtualizado));
		try{
			jogoIniciar.IniciarPartida();
		}	
		catch(GameException e)
		{
			String mensagem = String.format("Erro:%s\nReiniciando jogo",e.getMessage());
			fireDisplayChangeEvent(new ServerEvent(mensagem, TipoEvento.DisplayAtualizado));
			
		}
	}
	
	private Jogador encontrarJogadorPorIpEmJogo(Jogo jogo, Socket socketJogador){
		Jogador retorno = null;				
		for(Jogador obj : jogo.aListaJogador){
			if(obj.getConexao().socket == socketJogador){
				retorno = obj;
				break;
			}
		}
		
		return retorno;
		
	}

	private Jogador encontrarJogadorPorNome(String nomeChamado) {
		Jogador retorno = null;
		
		for(Jogador obj : aListaJogadorOnline){
			if(obj.getLogin().equals(nomeChamado)){
				retorno = obj;
				break;
			}
		}
		return retorno;
	}
	
	private Jogador encontrarJogadorPorIp(String ipJogador){
		Jogador retorno = null;
				
		for(Jogador obj : aListaJogadorOnline){
			if(obj.getIpJogador().equalsIgnoreCase(ipJogador)){
				retorno = obj;
				break;
			}
		}
		
		return retorno;
		
	}

	/*Métodos para manipulação de eventos*/
	
	public void AddServerEventListener(ServerEventListener listener){
		listenerList.add(ServerEventListener.class, listener);
	}
	public void RemoveServerEventListener(ServerEventListener listener){
		listenerList.remove(ServerEventListener.class, listener);
	}
	
	void firePlayerListChangeEvent(ServerEvent evt) {
        Object[] listeners = listenerList.getListenerList();
        // Each listener occupies two elements - the first is the listener class
        // and the second is the listener instance
        for (int i=0; i<listeners.length; i+=2) {
            if (listeners[i]==ServerEventListener.class) {
                ((ServerEventListener)listeners[i+1]).playerListChanged(evt);
            }
        }
    }
	
	void fireDisplayChangeEvent(ServerEvent evt) {
        Object[] listeners = listenerList.getListenerList();
        // Each listener occupies two elements - the first is the listener class
        // and the second is the listener instance
        for (int i=0; i<listeners.length; i+=2) {
            if (listeners[i]==ServerEventListener.class) {
                ((ServerEventListener)listeners[i+1]).updateDisplay(evt);
            }
        }
    }
	
	void fireGamesListChangeEvent(ServerEvent evt) {
        Object[] listeners = listenerList.getListenerList();
        // Each listener occupies two elements - the first is the listener class
        // and the second is the listener instance
        for (int i=0; i<listeners.length; i+=2) {
            if (listeners[i]==ServerEventListener.class) {
                ((ServerEventListener)listeners[i+1]).gamesListChanged(evt);
            }
        }
    }

	@Override
	public void socketFinalizado(Socket socket) {
		Jogador jogador = this.encontrarJogadorPorSocket(socket);
		
		if(jogador != null){
			aListaJogadorJogando.remove(jogador);
			aListaJogadorOnline.remove(jogador);
			Jogo jogoRemover = this.encontrarJogoPorId(jogador.getJogoId());
			//Remove o jogador do jogo, se ele estiver em um, e também remove o jogo da lista de jogos se este não tiver jogadores
			if(jogoRemover != null){
				jogoRemover.removerJogador(jogador);
				if(jogoRemover.isVazio()){
					aListaJogos.remove(jogoRemover);	
				}
			}
			
			firePlayerListChangeEvent(new ServerEvent(aListaJogadorJogando, TipoEvento.JogadoresAtualizados));
			fireGamesListChangeEvent(new ServerEvent(aListaJogos, TipoEvento.JogosAtualizados));
			fireDisplayChangeEvent(new ServerEvent(String.format("%s não está mais comunicável", jogador.getLogin()), TipoEvento.DisplayAtualizado));
		}
	}

}
